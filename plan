Mulligan Instant Framework

- TODO:
    - Simple UI with variables
    - profiler
    - Network
    - DefaultFloat

- Principles (for readme):
	- A framework for building stuff fast, flexibly, and well
	- Sensible defaults for everything
	    - justification - fast code
	- Minimize dependencies
	    - justification: dependencies cause problems.  It's often said to not "reinvent the wheel", which is true, but
	    the outsourced wheel can bring incompatibilities, loss of control, unfixable bugs, the need to learn new systems,
	    etc. So this framework will not reinvent wheels, but will look at less necessary helper-type dependencies
	    (e.g. Google Guice) as an evil.  Additionally dependencies will be chosen which deviate from standard practice as
	    minimally as possible.
	- Maximize debugging capability
	    - justification: so much time is wasted in figuring out why something just isn't working.  If you can access all
	    the things you need to, this shouldn't be a problem.
    - Minimize unfamiliarity - for end user, should be familiar enough that it feels like Java or some other simple language
- goal: solve major modular programming challenges so that applications can be deployed very rapidly
	- minimal/no setup
    	- after downloading, you should basically type one word and have a server running that pulls demo data
	- useful defaults, only require stuff to be tweaked
	    - throw out any ideas of doing this properly that require time investment every time you build something
	    - but not limiting in any way
	    - should have very common utilities included by default - logging, profiling, object browser, networking, UI, storage
	- loose coupling - should be easy to build new modules and swap one for another.
- Not priorities:
    - performance
    - encapsulation of defaults.  These aren't libraries, they are just defaults to be overridden where needed.
- What are the problems?
	- Testing - it's virtually impossible to write enough test to cover all edge cases.  Also there's the testing paradox - if your tests cover all cases, why do you need code?
		- creating test data can be a bitch
		- testing across services is a serious problem
	- Network Communication 
		- Debugging why some endpoint isn't getting anything
			- goal every error should have one cause (including soft errors like not getting anything)
	- Storage
		- it's just tedious - gotta provision tables, check connections, etc.  Note that in Quintiq this was seamless.
	- Input/output handling - it becomes tedious to drill down to the data you want
	- UI - Interacting/seeing what your program's doing becomes difficult
		- again, quintiq solved by having analysis grid
	- Dependencies 
		- Dependency injection sucks, too hard to figure out where something should come from
		- Build files suck, impossible to find out what magical string you need to put in to make it work
			- possible solution: dependency module.  Library has a file or a string somewhere that you just copy and paste into build
		- Dependency hierarchy - reduce, reuse, loose couple
	- errors - 
		- error messages are frequently unclear, useless, or just plain wrong
		- warning messages are excessive and get skipped over
- Solution: default module
	- Comes with defaults for each of the five areas above:
		- Testing 
			- code is self-testing.  
			- Have @test annotation for functions with sample inputs and outputs
			- Every function automatically has a default output that can change with annotation
			- if add /test to service call it will respond with test data
		- Network communication - 
			- server connection - Have "upstream server(s)" and "downstream server(s)", Error if not set (set to null if not needed)
				- if either is not null and fails to connect, should have clear and obvious error explaining this
				- likewise if no events but is connected, should indicate this
				- assumption is that other server is the same module.  So we can use this to send "tracer" events that verify connection, speed, etc.
		- Storage 
			- Integrated storage like we did with railtrak
				- every defaultobject is a table with key-value store, but use sql so it can also use columns if needed
			- can store to regular DB or to json store
			- stores to json flat file by default
		- I/O handling 
			- default data structure (base class) for events with payload and metadata
			- payload is a map of DefaultData by default.  Metadata is a map of anyval by default.
				- payload map can be subclassed to predictable types of maps?
				- Payload is trait that extends Map, has mutable and immutable subtypes
				- payload.save - stores it to defaultStorage
					- or automatically stores on change?
			- dealing with subclasses - is there a way to make this unnecessary?  Doing match case is annoying.
				- if A: Anyval = B: Anyval, can we somehow make A the same type as B?  Like A: [B.getclass]?
				- Or maybe have a method like "A: SomeObject = FindOn(B)" where it drills down B until it finds a SomeObject
				- what about DO.convertToSubclass()?  Is there some magical way to make this work using scala type classes?
		- UI - starts at base object, drills down
		    - output to cmd?  If so must refresh and be turn-offable
		- Dependencies - 
			- Everything is a variadic and backwards compatible?  Maybe this problem isn't worth worrying about...
		- automatic errors with useful messages?
	- Workflows?  Like starts with event, then processes, then has output event.  This is default workflow but others can be added.
		- benefit is can build specific debugging for this
		- worried this will be limiting
		- but can make this a modular design.  Like input module, processor module, output module.  People can make their own modules - add more processors, inputs, outputs, custom modules (e.g. eternal loop module)
	- have separate loosely-coupled libraries
		- DefaultObject - handles testing, storage, on it's own, has its own API endpoint
			- has single primary value.  Value can be anything, including a default object or list of DefaultObjects
			- has default values for testing
			- exports api endpoint (with get, put, etc.) to api module
		- DefaultModule - has a DefaultObject for System, with payload consisting of basic predictable things, and a daemon that runs every second by default.
			- so don't need to define endpoints. Name of DM is automatically an endpoint.  
				- Put/key/value/ adds to map
				- get/key reads from map.  No key gets whole map
				- Delete(key) deletes from map
			- can be built programmatically
			- ideally, every defaultmodule is its own service and has only one defaultobject payload
			- comes with server
			- has its own storage and UI for storage.  So DM/Store gets a UI to see data.
		- DefaultWorkflow 
			- Input/Output workflow.  
				- Basically define input (can be kafka, endpoint, excel sheet, whatever).  Default is https://api.imgflip.com/get_memes.  Default behavior is to convert the kafka event to a serious of default objects for each level.
				- Define output as UI, database, kafka stream, whatever. In this case saves result to log file.  Default log file output is DefaultObject.toString()
				- then have conversion def that does the conversion. In this case it's basically "def convert(DefaultObject): DefaultObject = input". 
				- can have multiple input modules
			- Library can include generic things like KafkaInput, FileOutput, etc.
	- sample - notification service with all DefaultModules
		- DM#1 - listener - uses I/O workflow
			- input is kafka event (need to configure connection info, have good debug messages in KafkaInput module)
			- output is default database.  def convert = (converts kafka DefaultObject to Notification DefaultObject for storage, uses findOn() to get data.).
			- testing - call event/get/events/test, see if notification created.
		- DM#2 - daemon - uses I/O workflow
			- input is database, time index
			- output is kafka stream ...
		- DM#3 - executor - uses I/O workflow
	- sample 2 - demo user story (idealized)
		- mulligan.start()
			- runs server
			- has ping endpoint
			- stores each ping 
			- can then override as needed
		- convert to usable app (executor service)
			- change input from server to kafka event - do by swapping out API entry module with kafka module
				- input module produces a default object output.  Basically create new module that converts a kafka event to a defaultObject
				- change processor logic.  Processor now routes default object (after checking decider) to output
				- output module is swapped to API call to notification service
			- point - there's predictability here
		- other sugar
			- APICall trait - includes automatic error handling, if you don't specify a server or endpoint it warns you.  If there's an error, it says "You are using default endpoint" in the error.  Warnings are combined with errors.
			- warnings are limited so they are actually useful.  By default, more than 5 warnings won't compile.
			- run test - it immediately finds unexpected bug - defaultObject input not compatible type (KafkaEvent doesn't match APIRequest)

the problem of implicits (implicit in scala seems to mean, "defined somewhere not obvious")
- We want to add save behavior to ints, so when we save structs with ints they get saved correctly.
- We could do this with implicit class that adds behavior to new int class.  
- Problem: if some error is thrown by save, it will not be obvious to unfamiliar user what is going on
	- why?  Because user expects any call on Int to be in Int class.  But Int.save() is in DefaultInt class. 
- Is there another way to do this?
	- original plan: defaultInt() - can we make this a subclass of int?  So you declare a default int but it still behaves as an Int.
		- Answer? No.  Int cannot be subclassed
	- Train-tracker solution - make a separate class for each type like SAInt, SAReal, etc.  These are each subclass of StoredAttribute.
		- This takes away base type behavior though
		- This is probably the best solution because explicitly adding base behavior is kind of trivial.
	- Use implicits, but somehow make it more readable
		- Implicits need to be declared/obvious somehow.  Principle that can debug by looking at code should apply.
		- e.g. 2+2, 2.testMe... where is testMe?  
			- every extended method should begin or end with implicit className
